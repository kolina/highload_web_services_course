Опишем CP-подобный дизайн нашего сервиса, использующий в качестве бекенда MongoDB. Будем хранить все письма в одной коллекции, причем каждое письмо будет представлять собой документ вида:
```
{
  "user_ids": ["1234", "1235", "1236"],
  "sender": "1234",
  "to": ["1235"],
  "from": ["1236"],
  "thread_id": "123456",
  "theme": string,
  "body": string
}
```
Такая схема позволяет построить индексы по юзеру и треду для эффективных выборок из коллекции. Таким образом, операция отправления письма будет представлять собой вставку одного документа в коллекцию. Остальные операции будут представлять собой выборку из коллекции с фильтрацией по `user_id` и возможно, `thread_id` или внутреннему `_id` документа.
При вставке документа будем использовать `writeConcern=majority`, а при запросах на чтение использовать `readConcern=linearizable` (появился в версии 3.4 https://docs.mongodb.com/manual/reference/read-concern/, он лечит проблему `stale reads`, описанную здесь https://aphyr.com/posts/322-call-me-maybe-mongodb-stale-reads). В теории, описанный подход должен обеспечить консистентность видимости данных на уровне одного документа. Поэтому в данном плане мы получим CP-систему.
