Опишем CP-подобный дизайн нашего сервиса, использующий в качестве бекенда MongoDB. Будем хранить все письма в одной коллекции, причем каждое письмо будет представлять собой документ вида:
```
{
  "user_ids": ["1234", "1235", "1236"],
  "sender": "1234",
  "to": ["1235"],
  "from": ["1236"],
  "thread_id": "123456",
  "theme": string,
  "body": string
}
```
Такая схема позволяет построить индексы по юзеру и треду для эффективных выборок из коллекции. Таким образом, операция отправления письма будет представлять собой вставку одного документа в коллекцию. Остальные операции будут представлять собой выборку из коллекции с фильтрацией по `user_id` и возможно, `thread_id` или внутреннему `_id` документа.
При вставке документа будем использовать `writeConcern=majority`, а при запросах на чтение использовать `readConcern=linearizable` (появился в версии 3.4 https://docs.mongodb.com/manual/reference/read-concern/, он лечит проблему `stale reads`, описанную здесь https://aphyr.com/posts/322-call-me-maybe-mongodb-stale-reads). В теории, описанный подход должен обеспечить консистентность видимости данных на уровне одного документа. Поэтому в данном плане мы получим CP-систему.
Был выбран CP подход по следующим соображениеям: для почтовых сообщений является важным, на мой взгляд, то свойство, чтобы пользователи видели их состояние консистентно. Т.е. не должно быть ситуации, чтобы мы отрапортовали об успешной отсылке письма отправителю, но получатели его не видели. Лучше сообщить отправителю о неудаче, чтобы он потом попытался перепослать, но сохранить состояние почтовой базы в консистентном состоянии.
